<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ CleanupBehavior processor="T4VSHost" CleanupAfterProcessingtemplate="true" #>

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq;
using System.Collections.Generic;
<#    if (Configuration.EnableWebCode) { #>
using System.Web.Mvc;
using System.Web;
using System.Security.Claims;

<#    } #>

namespace <#= Configuration.Namespace #>
{
    public static class <#= Configuration.EnumName #>
    {<# 
        Write(Helpers.PrintEnumProperties(Configuration.Nodes)); 
        Write(Helpers.PrintMasterValuesMap(Configuration.Nodes)); 
        Write(Helpers.PrintRolePermissionDictionary());
    #>

        public static List<string> Values { get => ValuesMap.Values.ToList(); }
        public static List<string> Keys { get => ValuesMap.Keys.ToList(); }
        
        // CanDoThing => thing.can.do
        public static List<KeyValuePair<string,string>> ToList()
        {
            return ValuesMap.ToList();
        }

        /// <summary>
        /// Lists all roles that have the given fully qualified permission node.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static List<string> GetRolesThatHavePermission(string node)
        {
            List<string> items = new List<string>();

            foreach(var grp in Permissions.RolePermissions.Keys)
            {
                if (Permissions.HasPermissionByRole(grp, node))
                {
                    items.Add(grp);
                }
            }

            return items;
        }


        ///<summary>
        /// This method checks to see if any of the roles in the rolecsv (list of roles, separated by commas)
        /// have the requested permission node. Returns true if any of them do. The full qualified permission
        /// node needs to come from the pre-defined constant values.
        ///</summary>
        public static bool HasPermissionByRole(string roleCsv, string fullyQualifiedPermissionNode)
        {
			if (string.IsNullOrWhiteSpace(roleCsv)) return false;
            string[] roles = roleCsv.Split(',').Select(x => x.Trim()).ToArray();

            foreach(string role in roles)
            {
                if (RolePermissions.ContainsKey(role))
                {
                    var perms = RolePermissions[role];
                    if (perms != null && perms.Contains(fullyQualifiedPermissionNode))
                    {
                        return true;
                    }
                }
            }

            return false;
        }


        public static void AddPermission(string role, string node)
        {
            if (!RolePermissions.ContainsKey(role)) RolePermissions[role] = new HashSet<string>();
            var nodes = GetFullyQualifiedPermissionNodes(node);

            foreach(string fq in nodes)
            {
                RolePermissions[role].Add(fq);
            }
        }

        public static void AddPermissions(string role, HashSet<string> nodes)
        {
            if (!RolePermissions.ContainsKey(role)) 
            {
                RolePermissions[role] = new HashSet<string>();
            }

            foreach(string s in nodes)
            {
                var fqNodes = GetFullyQualifiedPermissionNodes(s);
                foreach(string fq in fqNodes)
                {
                    RolePermissions[role].Add(fq);
                }
            }
        }
    
        private static HashSet<string> GetFullyQualifiedPermissionNodes(string nodeWithPossibleWildCard)
        {
            HashSet<string> nodes = new HashSet<string>();
            if (ValuesMap.Values.Contains(nodeWithPossibleWildCard))
            {
                nodes.Add(nodeWithPossibleWildCard);
            }
            else
            {
                // must be either not found, or a wildcard. Wildcard if ending in *
                if (nodeWithPossibleWildCard.EndsWith("*"))
                {
                    if (nodeWithPossibleWildCard == "*")
                    {
                        foreach(string fq in ValuesMap.Values)
                        {
                            nodes.Add(fq);
                        }
                    }
                    else if (nodeWithPossibleWildCard.EndsWith(".*"))
                    {
                        string needle = nodeWithPossibleWildCard.Substring(0, nodeWithPossibleWildCard.Length - 2);
                        foreach (string fq in ValuesMap.Values.Where(x => x.StartsWith(needle)))
                        {
                            nodes.Add(fq);
                        }
                    }
                }
            }

            return nodes;
        }
        

<#    if (Configuration.EnableWebCode) { #>

        ///<summary>
		/// Returns a comma separated vector of roles for the current user. This is stored as a
		/// Func<string> variable so that test implementations can override the default behavior here.
        ///</summary>
		public static Func<string> GetRolesCsvForCurrentUser = () => 
		{
            if (HttpContext.Current?.User?.Identity != null)
            {
                var ident = HttpContext.Current?.User.Identity;
                if (ident.IsAuthenticated)
                {
                    if (HttpContext.Current?.User is ClaimsPrincipal)
                    {
                        var principal = (ClaimsPrincipal) HttpContext.Current?.User;
                        string rolesCsv = principal.FindFirst(ClaimTypes.Role)?.Value;
                        return rolesCsv;
                    }
                }
            }

            return "";
        };


        ///<summary>
        /// This method checks a user's Role claim csv for roles. It then checks to see if any of those roles
        /// have the requested permission node.
        ///</summary>
        public static bool HasPermission(string node)
        {
            return HasPermissionByRole(GetRolesCsvForCurrentUser(), node);
        }


        ///<summary>
        /// This method checks a user's Role claim csv for roles. It then checks to see if any of those roles
        /// have the requested permission node.
        ///</summary>
        public static bool HasPermission(this HtmlHelper html, string node)
        {
            return HasPermissionByRole(GetRolesCsvForCurrentUser(), node);
        }
        <#
    }
#>  
    }
}
    
    <#    if (Configuration.EnableMvcControllerAttribute) { #>

namespace System.Web.Mvc
{

    #region HasPermissionAttribute (MVC)

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    public class HasPermissionAttribute : ActionFilterAttribute, IActionFilter
    {
        public string[] Nodes { get; set; }
        public HasPermissionAttribute(string PermissionNode)
        {
            this.Nodes = new string[] { PermissionNode };
        }

        public HasPermissionAttribute(params string[] PermissionNodes)
        {
            this.Nodes = PermissionNodes;
        }

        void IActionFilter.OnActionExecuting(ActionExecutingContext filterContext)
        {
            foreach(string fqNode in this.Nodes)
            {
                if (<#= Configuration.Namespace +"."+ Configuration.EnumName #>.HasPermission(fqNode))
                {
                    return; // Good to go. You have permission.
                }
            }
            // Hello World
            filterContext.Result = new RedirectToRouteResult(new System.Web.Routing.RouteValueDictionary(new { area = String.Empty, controller = "Error", action = "Index", id = 403 }));
        }
    }

	#endregion
}
<# } #>


<#	if (Configuration.EnableApiControllerAttribute) { #>

namespace System.Web.Http
{

    #region HasPermissionAttribute (Api)
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    public class HasPermissionAttribute : System.Web.Http.Filters.ActionFilterAttribute, System.Web.Http.Filters.IActionFilter
    {
        public string[] Nodes { get; set; }
        public HasPermissionAttribute(string PermissionNode)
        {
            this.Nodes = new string[] { PermissionNode };
        }

        public HasPermissionAttribute(params string[] PermissionNodes)
        {
            this.Nodes = PermissionNodes;
        }

        public override void OnActionExecuted (System.Web.Http.Filters.HttpActionExecutedContext filterContext)
        {
            foreach(string fqNode in this.Nodes)
            {
                if (Azure4Educators.API.Permissions.HasPermission(fqNode))
                {
                    return; // Good to go. You have permission.
                }
            }

            JsonPayload<object> result = new JsonPayload<object>();
            if (Nodes.Length == 1)
            {
                result.Errors.Add(string.Format(LocalizationResources.Resources.Error_PermissionDenied_0, Nodes.FirstOrDefault()));
            }
            else
            {
                result.Errors.Add(string.Format(LocalizationResources.Resources.Error_PermissionDenied_0, "["+string.Join(",",Nodes)+"]"));
            }

            filterContext.Response = new System.Net.Http.HttpResponseMessage(System.Net.HttpStatusCode.Unauthorized)
            {
                Content = new System.Net.Http.StringContent(result.ToJsonString(), System.Text.Encoding.UTF8, "application/json"),
                ReasonPhrase = System.Net.HttpStatusCode.Unauthorized.ToString()
            };
        }
    }
	#endregion
}

<#	} #>
<#+

public static class Helpers
{

        private static bool HasPermission(string fullyQualifiedPermissionNode, HashSet<string> givenPermissions)
        {
            if (givenPermissions == null || givenPermissions.Any() == false) return false;
            if (givenPermissions.Contains(fullyQualifiedPermissionNode)) return true;
            if (givenPermissions.Contains("*")) return true;

            string[] args = fullyQualifiedPermissionNode.Split('.');
            string needle = "";
            for (int i = 0; i < args.Length; i++)
            {
                if (i > 0) needle += ".";
                needle += args[i];
                if (givenPermissions.Contains(needle + ".*")) return true;
            }

            return false;
        }

        // Expands the specified permission nodes into the fully qualified permission nodes.
        public static string PrintRolePermissionDictionary(){
            var initialPermissions = Configuration.ConfigureRolePermissions();
            var compiledPermissions = Helpers.GetValuesMap();

            string output = "\r\n\r\n";
            output += Helpers._(8)+"//Role -> permissions[]\r\n        public static readonly Dictionary<string, HashSet<string>> RolePermissions = new Dictionary<string, HashSet<string>>()\r\n"+_(8)+"{\r\n";
            
            foreach(var grp in initialPermissions.Keys){
                var hashSetOfGroupPerms = new HashSet<string>(initialPermissions[grp]);
                var fullyQualifiedNodes = compiledPermissions.Where(permNode => Helpers.HasPermission(permNode.Value, hashSetOfGroupPerms)).Select(x => x.Value).OrderBy(x => x);
                output += _(12) + "{ \""+grp+"\", new HashSet<string>(){ ";
                if (fullyQualifiedNodes.Any()){
                    output += "\""+string.Join("\",\"",fullyQualifiedNodes)+"\" }},\r\n";
                }else{
                    output += "}},\r\n";
                }
            }
            output += Helpers._(8) + "};\r\n";

            return output;
        }
 
        
        public static string PrintEnumProperties(object nodes)
        {
            string o = "";
            Type nodesTp = Configuration.Nodes.GetType();
            PropertyInfo[] props= nodesTp.GetProperties();
            
            for(int i = 0; i < props.Length; i++)
            {
                var prop = nodesTp.GetProperties()[i];
                o += "\r\n        public const "+prop.PropertyType+" "+prop.Name+ " = "+Helpers.PrintPropertyValue(prop,Configuration.Nodes)+ ";";
            }
            o += "\r\n\r\n";

            return o;
        }

        private static Dictionary<string, string> GetValuesMap()
        {
            Type nodesTp = Configuration.Nodes.GetType();
            PropertyInfo[] props= nodesTp.GetProperties();
            var dic = new Dictionary<string,string>();
            for(int i = 0; i < props.Length; i++)
            {
                var prop = nodesTp.GetProperties()[i];
                dic[prop.Name] = prop.GetValue(Configuration.Nodes).ToString();
            }
            return dic;
        }

        public static string PrintMasterValuesMap(object nodes)
        {
            Type nodesTp = Configuration.Nodes.GetType();
            PropertyInfo[] props= nodesTp.GetProperties();
            string o = "        private static readonly Dictionary<string, string> ValuesMap = new Dictionary<string, string>()\r\n        {";
            for(int i = 0; i < props.Length; i++)
            {
                var prop = nodesTp.GetProperties()[i];
                o += "\r\n            { \""+prop.Name+"\", "+(Helpers.PrintPropertyValue(prop,Configuration.Nodes)+" },");
            }
            o += ("\r\n        };\r\n");

            return o;
        }
        

        public static string PrintPropertyValue(PropertyInfo prop, object objInstance)
        {
            switch(prop.PropertyType.ToString()){
                case "System.Double":
                    return prop.GetValue(objInstance).ToString()+"D";
                case "System.Float":
                    return prop.GetValue(objInstance).ToString()+"F";
                case "System.Decimal":
                    return prop.GetValue(objInstance).ToString()+"M";
                case "System.Long":
                    return prop.GetValue(objInstance).ToString()+"L";
                case "System.Boolean": 
                case "System.Int16":
                case "System.Int32":
                    return prop.GetValue(objInstance).ToString().ToLowerInvariant();
                case "System.String":
                    return "\""+prop.GetValue(objInstance)+"\"";
            }

            return prop.GetValue(objInstance).ToString();
        }

        public static string _ (int numSpaces)
        {
            string o = "";
            for(int i = 0; i < numSpaces; i++){
                o += " ";
            }

            return o;
        }
}
#>