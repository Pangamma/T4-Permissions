
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Linq;
using System.Collections.Generic;
using System.Web.Mvc;
using System.Web;
using System.Security.Claims;


namespace ImagineBrownBag
{
    public static class Permissions
    {
        public const System.String CanDoFoo = "foo.do";
        public const System.String CanAdjustTempurature = "tempurature.adjust";
        public const System.String CanViewTempurature = "tempurature.view";
        public const System.String CanWatchTV = "entertainment.tv.watch";
        public const System.String CanChangeTvVolume = "entertainment.tv.change.volume";
        public const System.String CanChangeTvChannel = "entertainment.tv.change.channel";
        public const System.String CanPlayVideoGames = "entertainment.videogames.play";
        public const System.String CanWatchOtherPeoplePlayVideoGames = "entertainment.videogames.view";

        private static readonly Dictionary<string, string> ValuesMap = new Dictionary<string, string>()
        {
            { "CanDoFoo", "foo.do" },
            { "CanAdjustTempurature", "tempurature.adjust" },
            { "CanViewTempurature", "tempurature.view" },
            { "CanWatchTV", "entertainment.tv.watch" },
            { "CanChangeTvVolume", "entertainment.tv.change.volume" },
            { "CanChangeTvChannel", "entertainment.tv.change.channel" },
            { "CanPlayVideoGames", "entertainment.videogames.play" },
            { "CanWatchOtherPeoplePlayVideoGames", "entertainment.videogames.view" },
        };


        //Role -> permissions[]
        public static readonly Dictionary<string, HashSet<string>> RolePermissions = new Dictionary<string, HashSet<string>>()
        {
            { "Parent", new HashSet<string>(){ "entertainment.tv.change.channel","entertainment.tv.change.volume","entertainment.tv.watch","entertainment.videogames.play","entertainment.videogames.view","foo.do","tempurature.adjust","tempurature.view" }},
            { "Student", new HashSet<string>(){ "tempurature.adjust","tempurature.view" }},
            { "Student without homework", new HashSet<string>(){ "entertainment.tv.change.channel","entertainment.tv.change.volume","entertainment.tv.watch","entertainment.videogames.play","entertainment.videogames.view","tempurature.adjust","tempurature.view" }},
            { "Baby", new HashSet<string>(){ "entertainment.tv.watch","tempurature.view" }},
        };

        public static List<string> Values { get => ValuesMap.Values.ToList(); }
        public static List<string> Keys { get => ValuesMap.Keys.ToList(); }
        
        // CanDoThing => thing.can.do
        public static List<KeyValuePair<string,string>> ToList()
        {
            return ValuesMap.ToList();
        }

        /// <summary>
        /// Lists all roles that have the given fully qualified permission node.
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static List<string> GetRolesThatHavePermission(string node)
        {
            List<string> items = new List<string>();

            foreach(var grp in Permissions.RolePermissions.Keys)
            {
                if (Permissions.HasPermissionByRole(grp, node))
                {
                    items.Add(grp);
                }
            }

            return items;
        }


        ///<summary>
        /// This method checks to see if any of the roles in the rolecsv (list of roles, separated by commas)
        /// have the requested permission node. Returns true if any of them do. The full qualified permission
        /// node needs to come from the pre-defined constant values.
        ///</summary>
        public static bool HasPermissionByRole(string roleCsv, string fullyQualifiedPermissionNode)
        {
			if (string.IsNullOrWhiteSpace(roleCsv)) return false;
            string[] roles = roleCsv.Split(',').Select(x => x.Trim()).ToArray();

            foreach(string role in roles)
            {
                if (RolePermissions.ContainsKey(role))
                {
                    var perms = RolePermissions[role];
                    if (perms != null && perms.Contains(fullyQualifiedPermissionNode))
                    {
                        return true;
                    }
                }
            }

            return false;
        }


        public static void AddPermission(string role, string node)
        {
            if (!RolePermissions.ContainsKey(role)) RolePermissions[role] = new HashSet<string>();
            var nodes = GetFullyQualifiedPermissionNodes(node);

            foreach(string fq in nodes)
            {
                RolePermissions[role].Add(fq);
            }
        }

        public static void AddPermissions(string role, HashSet<string> nodes)
        {
            if (!RolePermissions.ContainsKey(role)) 
            {
                RolePermissions[role] = new HashSet<string>();
            }

            foreach(string s in nodes)
            {
                var fqNodes = GetFullyQualifiedPermissionNodes(s);
                foreach(string fq in fqNodes)
                {
                    RolePermissions[role].Add(fq);
                }
            }
        }
    
        private static HashSet<string> GetFullyQualifiedPermissionNodes(string nodeWithPossibleWildCard)
        {
            HashSet<string> nodes = new HashSet<string>();
            if (ValuesMap.Values.Contains(nodeWithPossibleWildCard))
            {
                nodes.Add(nodeWithPossibleWildCard);
            }
            else
            {
                // must be either not found, or a wildcard. Wildcard if ending in *
                if (nodeWithPossibleWildCard.EndsWith("*"))
                {
                    if (nodeWithPossibleWildCard == "*")
                    {
                        foreach(string fq in ValuesMap.Values)
                        {
                            nodes.Add(fq);
                        }
                    }
                    else if (nodeWithPossibleWildCard.EndsWith(".*"))
                    {
                        string needle = nodeWithPossibleWildCard.Substring(0, nodeWithPossibleWildCard.Length - 2);
                        foreach (string fq in ValuesMap.Values.Where(x => x.StartsWith(needle)))
                        {
                            nodes.Add(fq);
                        }
                    }
                }
            }

            return nodes;
        }
        


        ///<summary>
		/// Returns a comma separated vector of roles for the current user. This is stored as a
		/// Func<string> variable so that test implementations can override the default behavior here.
        ///</summary>
		public static Func<string> GetRolesCsvForCurrentUser = () => 
		{
            if (HttpContext.Current?.User?.Identity != null)
            {
                var ident = HttpContext.Current?.User.Identity;
                if (ident.IsAuthenticated)
                {
                    if (HttpContext.Current?.User is ClaimsPrincipal)
                    {
                        var principal = (ClaimsPrincipal) HttpContext.Current?.User;
                        string rolesCsv = principal.FindFirst(ClaimTypes.Role)?.Value;
                        return rolesCsv;
                    }
                }
            }

            return "";
        };


        ///<summary>
        /// This method checks a user's Role claim csv for roles. It then checks to see if any of those roles
        /// have the requested permission node.
        ///</summary>
        public static bool HasPermission(string node)
        {
            return HasPermissionByRole(GetRolesCsvForCurrentUser(), node);
        }


        ///<summary>
        /// This method checks a user's Role claim csv for roles. It then checks to see if any of those roles
        /// have the requested permission node.
        ///</summary>
        public static bool HasPermission(this HtmlHelper html, string node)
        {
            return HasPermissionByRole(GetRolesCsvForCurrentUser(), node);
        }
          
    }
}
    
    
namespace System.Web.Mvc
{

    #region HasPermissionAttribute (MVC)

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    public class HasPermissionAttribute : ActionFilterAttribute, IActionFilter
    {
        public string[] Nodes { get; set; }
        public HasPermissionAttribute(string PermissionNode)
        {
            this.Nodes = new string[] { PermissionNode };
        }

        public HasPermissionAttribute(params string[] PermissionNodes)
        {
            this.Nodes = PermissionNodes;
        }

        void IActionFilter.OnActionExecuting(ActionExecutingContext filterContext)
        {
            foreach(string fqNode in this.Nodes)
            {
                if (ImagineBrownBag.Permissions.HasPermission(fqNode))
                {
                    return; // Good to go. You have permission.
                }
            }
            // Hello World
            filterContext.Result = new RedirectToRouteResult(new System.Web.Routing.RouteValueDictionary(new { area = String.Empty, controller = "Error", action = "Index", id = 403 }));
        }
    }

	#endregion
}



